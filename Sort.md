### 冒泡排序：
    大致流程：  
        1：从第一个元素开始，与下一个元素进行比较，如果大则交换，否则不做处理
        2：将最大的数字放置到最后，然后对除最后一个元素的剩余元素进行循环判断
    优点：稳定
    缺点：排序速度慢
    时间复杂度：   
            最好情况：O(n)需要加一个标志
            最坏情况：O(n^2)
    空间复杂度：O(1)


### 快速排序：
    大致流程：
        1：设置头尾指针，选择中间元素，从后面开始依次找到一个比中间元素小的元素，交换头尾指针元素
        2：然后从头指针开始往后找到一个比中间元素大的元素，交换头尾指针
        3：直到头尾指针指向同一位置
        4：然后分治，中间元素之前的做为一个新数组进行上诉操作，中间元素后面的也作为一个新数组进行上述操作
        5：直到数组最小数组大小为0
    优点：排序速度快
    缺点：不稳定，当序列已经有序时很慢，而且当数据量大时，递归调用自身会带来一定的消耗，并且可能会爆栈
    时间复杂度：   
            最好情况：O(nlog2n)
            最坏情况：O(n^2)
    空间复杂度：
            O(nlog2n)

### 堆排序：
    大致流程：
        1：对数组建堆，从最后一个拥有子树的元素开始，依次判断
        2：找到左右，根的最大值放置到子树根节点
        3：建完堆之后，根节点为最大值，将根节点交换到数组末尾，然后弃尾重建（即对除尾节点外的重新建堆）
    优点：
    缺点：不适合数据较少的情况，不稳定
    时间复杂度：   
            最好情况：O(nlog2n)
            最坏情况：O(nlog2n)
    空间复杂度：
            O(1)

### 归并排序：
    大致流程：
    优点：对两个已有序序列排序，很快
    缺点：不适合数据量大，需要很大空间
    时间复杂度：   
            最好情况：
            最坏情况：
    空间复杂度：
    

        
